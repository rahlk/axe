<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
"http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
<title>logpy.html</title>
<meta http-equiv="content-type" content="text/html; charset=iso-8859-1" />
<link rel="stylesheet" href="style.css" type="text/css" />
<!--[if IE 6]>
<link rel="stylesheet" href="xfix.css" type="text/css" />
<![endif]-->
</head>
<body>
<div id="sidebar">
  <h1>Company Name </h1>
  <h2>place for your slogan</h2>
  <div id="menu"> 
  <a href="#">Home</a>
  <a href="#">Current page</a>
  <a href="#">Another</a>
  <a href="#">Example</a>
  <a href="#">Showcase</a>
  <a href="#">Links</a>
  <a href="#">Contact</a>
  </div>
  <h3>&quot;Lorem ipsum dolor sit&quot;</h3>

  <p>Lorem ipsum dolor sit amet, consectetur
  adipisicing elit, sed do eiusmod tempor incididunt
  ut labore et dolore magna aliqua. Ut enim ad minim
  veniam, quis nostrud exercitation <a
  href="#">ullamco laboris</a> nisi ut aliquip ex ea
  commodo consequat. Duis aute irure dolor in
  reprehenderit in voluptate velit esse cillum
  dolore eu fugiat nulla pariatur. Excepteur sint
  occaecat cupidatat non proident, sunt in culpa qui
  officia deserunt mollit anim id est laborum.</p></div>
<div id="content"><p>[[etc/img/leftarrow.png]] [Back to SBSE'14](Home)</p>
<h1 id="log">log</h1>
<p><em>View this source at <a href="https://github.com/timm/sbse14">the code directory</a>.</em></p>
<hr />
<p>Logs are places to store records of past events. There are two types of logs:</p>
<ul>
<li><em>Num</em> : for numbers</li>
<li><em>Sym</em> : for everything else.</li>
</ul>
<p>Those logs can be queried to find e.g. the highest and lowest value ofthe number seen so far. Alternatively, they can be queried to returnvalues at the same probability as the current logcontents.</p>
<h3 id="max-log-size">Max Log Size</h3>
<p>To avoid logs consuming all memory, logs store atmost <em>The.cache.keep</em> entries (e.g. 128):</p>
<ul>
<li>If more than that number of entries arrive, then some oldentry (selected at random) will be deleted.</li>
<li>The nature of this cache means that some rareevents might be missed. To check for that, runningthe code multiple times and, each time, double thecache size. Stop when doubling the cache size stopschanging the output.</li>
</ul>
<p>Just as an example of that process, here we are logging 1,000,000 numbers in a log with a cache of size 16.Note that the resulting cache is much smaller than 1,000,000 items. Also, the contents of the cachecome from the entire range one to one million (so our log is not biased to just the first few samples:</p>
<pre><code> % python -i log.py
 &gt;&gt;&gt; The.cache.keep = 16
 &gt;&gt;&gt; log = Num()  
 &gt;&gt;&gt; for x in xrange(1000000): log += x 
 &gt;&gt;&gt; sorted(log._cache)
 [77748, 114712, 122521, 224268, 
 289880, 313675, 502464, 625036, 
 661881, 663207, 680085, 684674, 
 867075, 875594, 922141, 945896]
 &gt;&gt;&gt; </code></pre>
<h3 id="caching-slow-reports">Caching Slow Reports</h3>
<p>Some of the things we want to report from these logs take a little while to calculate (e.g. finding the medianrequires a sort of a numeric cache):</p>
<ul>
<li>Such reports should be run and cached so they can be accessed many time without the needfor tedious recalculation.</li>
<li>These reports become outdated if new log information arrives so the followingcode deletes these reports if ever new data arrives.</li>
<li>The protocol for access those reports is to call <em>log.has().x</em> where &quot;x&quot; is a field generated by the report. Log subclasses generate reports using the special <em>report()</em> method (see examples, below).</li>
</ul>
<p>Just as an example of reporting, after the above run (where we logged 1,000,000 numbers), the following reports are available:</p>
<pre><code> &gt;&gt;&gt; log.has().lo
 0 
 &gt;&gt;&gt; log.has().hi
 945896
 &gt;&gt;&gt; print log.has().median # 50th percentile
 662544.0
 &gt;&gt;&gt; print log.has().iqr # (75-25)th percentile
 205194</code></pre>
<p>Note that our median is not as expected (it should be around half a million). Why? Well, clearly a cache of size 16 istoo small to track a million numbers. So how many numbers do we need? Well, that depends on the distribution being exploredbut here's how the median is effected by cache size for uniform distributions:</p>
<pre><code>&gt;&gt;&gt; for size in [16,32,64,128,256]:
...     The.cache.keep=size
...     log = Num()
...     for x in xrange(1000000): log += x
...     print size, &quot;:&quot; log.has().median
... 
 16 : 637374.5
 32 : 480145.5
 64 : 520585.5
128 : 490742.0
256 : 470870.5</code></pre>
<p>Note that we get pretty close to half a million with cache sizes at 32 or above. And the lesson: sometimes, a limitedsample can offer a useful approximation to a seemingly complex process.</p>
<h2 id="standard-header">Standard Header</h2>
<pre class="sourceCode python"><code class="sourceCode python"><span class="ch">from</span> __future__ <span class="ch">import</span> division
<span class="ch">import</span> sys, random, math, datetime, time,re
sys.dont_write_bytecode = <span class="ot">True</span>
<span class="ch">from</span> base  <span class="ch">import</span> *
<span class="ch">from</span> stats <span class="ch">import</span> *</code></pre>
<h2 id="classes">Classes</h2>
<h3 id="base-class-log">Base Class: &quot;Log&quot;</h3>
<pre class="sourceCode python"><code class="sourceCode python"><span class="kw">class</span> Log():
  <span class="co">&quot;Keep a random sample of stuff seen so far.&quot;</span>
  <span class="kw">def</span> <span class="ot">__init__</span>(i,inits=[],label=<span class="st">&#39;&#39;</span>):
    i.label = label
    i._cache,i.n,i._report = [],<span class="dv">0</span>,<span class="ot">None</span>
    i.setup()
    <span class="dt">map</span>(i.<span class="ot">__iadd__</span>,inits)
  <span class="kw">def</span> <span class="ot">__iadd__</span>(i,x): <span class="co">#  magic method for &quot;+=&quot;</span>
    <span class="kw">if</span> x == <span class="ot">None</span>: <span class="kw">return</span> x <span class="co"># skip nothing</span>
    i.n += <span class="dv">1</span>
    changed = <span class="ot">False</span>
    <span class="kw">if</span> <span class="dt">len</span>(i._cache) &lt; The.cache.keep: <span class="co"># not full</span>
      changed = <span class="ot">True</span>
      i._cache += [x]               <span class="co"># then add</span>
    <span class="kw">else</span>: <span class="co"># otherwise, maybe replace an old item</span>
      <span class="kw">if</span> rand() &lt;= The.cache.keep/i.n:
        changed = <span class="ot">True</span>
        i._cache[<span class="dt">int</span>(rand()*The.cache.keep)] = x
    <span class="kw">if</span> changed:      
      i._report = <span class="ot">None</span> <span class="co"># wipe out &#39;what follows&#39;</span>
      i.change(x)
    <span class="kw">return</span> i
  <span class="kw">def</span> <span class="dt">any</span>(i):  
    <span class="kw">return</span>  <span class="dt">any</span>(i._cache)
  <span class="kw">def</span> has(i):
    <span class="kw">if</span> i._report == <span class="ot">None</span>: i._report =  i.report()
    <span class="kw">return</span> i._report
  <span class="kw">def</span> setup(i): <span class="kw">pass</span>
  <span class="kw">def</span> change(i,x): <span class="kw">pass</span></code></pre>
<h3 id="num">Num</h3>
<p>A <em>Num</em> is a <em>Log</em> for numbers.</p>
<ul>
<li>Tracks <em>lo</em> and <em>hi</em> values.</li>
<li>Reports median and the IQR the (75-25)th range.</li>
<li>Generates numbers from the log by a three-way interpolation (see <em>ish()</em>).</li>
</ul>
<pre class="sourceCode python"><code class="sourceCode python"><span class="kw">class</span> Num(Log):
  <span class="kw">def</span> setup(i):
    i.lo, i.hi = <span class="dv">10</span>**<span class="dv">32</span>, -<span class="dv">10</span>**<span class="dv">32</span>
  <span class="kw">def</span> change(i,x): <span class="co"># update lo,hi</span>
    i.lo = <span class="dt">min</span>(i.lo, x)
    i.hi = <span class="dt">max</span>(i.hi, x)
  <span class="kw">def</span> norm(i,x): <span class="co"># turn &quot;x&quot; into 0..1</span>
    <span class="kw">return</span> (x - i.lo)/(i.hi - i.lo + <span class="fl">0.000001</span>)
  <span class="kw">def</span> report(i): 
    lst = i._cache = <span class="dt">sorted</span>(i._cache)
    n   = <span class="dt">len</span>(lst)     
    <span class="kw">return</span> o(
      median= i.median(),
      iqr   = lst[<span class="dt">int</span>(n*.<span class="dv">75</span>)] - lst[<span class="dt">int</span>(n*.<span class="dv">5</span>)],
      lo    = i.lo, 
      hi    = i.hi)
  <span class="kw">def</span> ish(i,f=<span class="fl">0.1</span>): <span class="co"># return a num from  logged dist </span>
    <span class="kw">return</span> i.<span class="dt">any</span>() + f*(i.<span class="dt">any</span>() - i.<span class="dt">any</span>())
  <span class="kw">def</span> same(i,j):
    i.has()
    j.has()
    <span class="kw">return</span> a12(i._cache,j._cache) &lt;= The.misc.a12
  <span class="kw">def</span> median(i):
    n = <span class="dt">len</span>(i._cache)
    p = n // <span class="dv">2</span>
    <span class="kw">if</span> (n % <span class="dv">2</span>):  <span class="kw">return</span> i._cache[p]
    q = p + <span class="dv">1</span>
    q = <span class="dt">max</span>(<span class="dv">0</span>,(<span class="dt">min</span>(q,n)))
    <span class="kw">return</span> (i._cache[p] + i._cache[q])/<span class="dv">2</span>

<span class="kw">def</span> _num():
  i = Num([rand()      <span class="kw">for</span> _ in <span class="dt">xrange</span>(<span class="dv">1000</span>)])
  j = Num([rand()*<span class="fl">1.25</span> <span class="kw">for</span> _ in <span class="dt">xrange</span>(<span class="dv">1000</span>)])
  <span class="dt">print</span> j.same(i)</code></pre>
<p>WARNING: the call to <em>sorted</em> in <em>report()</em> makes this codea candidate for a massive CPU suck (it is always sorting newly arrived data).So distinguish between <em>adding</em> things to a log in the <em>last</em> era andusing that information in the <em>next</em> era (so the log from the last erais staple in the current).</p>
<h3 id="sym">Sym</h3>
<p>A <em>Sym</em> is a <em>Log</em> for non-numerics.</p>
<ul>
<li>Tracks frequency counts for symbols, and the most common symbol (the <em>mode</em>);</li>
<li>Reports the entropy of the space (a measure of diversity: lower values mean fewer rarer symbols);</li>
<li>Generated symbols from the log by returning symbols at the same probability of the frequency counts (see <em>ish()</em>).</li>
</ul>
<pre class="sourceCode python"><code class="sourceCode python"><span class="kw">class</span> Sym(Log):
  <span class="kw">def</span> setup(i):
    i.counts,i.mode,i.most={},<span class="ot">None</span>,<span class="dv">0</span>
  <span class="kw">def</span> report(i):
    <span class="kw">for</span> x in i._cache:
      c = i.counts[x] = i.counts.get(x,<span class="dv">0</span>) + <span class="dv">1</span>
      <span class="kw">if</span> c &gt; i.most:
        i.mode,i.most = x,c
    <span class="kw">return</span> o(dist= i.dist(), 
              ent = i.entropy(),
              mode= i.mode)
  <span class="kw">def</span> dist(i):
    d = i.counts
    n = <span class="dt">sum</span>(d.values())
    <span class="kw">return</span> <span class="dt">sorted</span>([(d[k]/n, k) <span class="kw">for</span> k in d.keys()], 
                  reverse=<span class="ot">True</span>)
  <span class="kw">def</span> ish(i):
    r,tmp = rand(),<span class="dv">0</span>
    <span class="kw">for</span> w,x in i.has().dist:
      tmp  += w
      <span class="kw">if</span> tmp &gt;= r: 
        <span class="kw">return</span> x
    <span class="kw">return</span> x
  <span class="kw">def</span> entropy(i,e=<span class="dv">0</span>):
    <span class="kw">for</span> k in i.counts:
      p = i.counts[k]/<span class="dt">len</span>(i._cache)
      e -= p*log2(p) <span class="kw">if</span> p <span class="kw">else</span> <span class="dv">0</span>
    <span class="kw">return</span> e    </code></pre>
<h4 id="sym-example">Sym, Example</h4>
<p>As an example of generating numbers from a distribution, consider the following code.The logged population has plus, grapes and pears in the ration 2:1:1.From that population, we can generate another distribution that is nearly the same:</p>
<pre><code>&gt;&gt;&gt; symDemo()
(0.5, &#39;plums&#39;), (0.265625, &#39;grapes&#39;), (0.234375, &#39;pears&#39;)]
{&#39;plums&#39;: 64, &#39;grapes&#39;: 34, &#39;pears&#39;: 30}</code></pre>
<pre class="sourceCode python"><code class="sourceCode python"><span class="kw">def</span> symDemo(n1=<span class="dv">10</span>,n2=<span class="dv">1000</span>):
  rseed()
  log= Sym(([<span class="st">&#39;plums&#39;</span>]*(n1*<span class="dv">2</span>)) + [<span class="st">&#39;grapes&#39;</span>]*n1 + [<span class="st">&#39;pears&#39;</span>]*n1)
  found= Sym([log.ish() <span class="kw">for</span> _ in <span class="dt">xrange</span>(n2)])
  <span class="dt">print</span> found.has().dist
  <span class="dt">print</span> found.counts
  <span class="dt">print</span> <span class="dt">sum</span>(found.counts.values())

<span class="kw">if</span> <span class="ot">__name__</span> == <span class="st">&quot;__main__&quot;</span>: <span class="dt">eval</span>(cmd()) 
</code></pre>
  <p>&nbsp;</p>
  <p>(c) 2004-2006 All rights reserved. <a href="#">Company Name. </a></p>
</div>
</body>
</html>